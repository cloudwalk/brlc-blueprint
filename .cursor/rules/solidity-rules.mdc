---
description: Rules for the solidity files
globs: *.sol
alwaysApply: false
---

# 1. General Instructions

1.  Act as an expert in Solidity and smart contract security.

2.  Follow the structure, development approaches, styles, formatting, comments according to the example project
    from section 6 `Example Project`.

3.  Follow the Solidity Style Guide from the language official documentation.

4.  Follow best practices and security recommendations from reputable companies and individuals.

5.  Use abstract contracts for base functionality that will be inherited.

6.  Use the base `Version` contract to add version information to production contracts.
    Do NOT add the version to intermediate and basic contracts.

7.  Separate storage layouts into dedicated contracts (like `BlueprintStorage`).

8.  Follow a consistent pattern for contract inheritance.

9.  Use interfaces to define external contract interactions.

10. Implement proper storage gap variables (like `uint256[46] private __gap`) in upgradeable production contracts.
    Do NOT add gap variables to intermediate and basic contracts.

11. Create testable versions of contracts with additional helper functions if needed.

12. Use mock contracts for testing base functionality.


# 2. Initializers Rules

1.  Upgradable abstract contracts must include one or two internal initializer function:
    unchained one (mandatory) and main one (optional). 
    E.g. for the `PausableExtUpgradeable` abstract smart contract must have the following initializers:
    `__PausableExt_init_unchained()` and `__PausableExt_init()`.

2.  The main initializer of an upgradable abstract contract must call all NON-EMPTY initializers (unchained or main) of
    all parent smart contracts.

3.  EMPTY unchained initializers of all parent contracts must NOT be called,
    including one from the current smart contract.

4.  If both (main and unchained) internal initializers of an upgradable abstract contract are empty then
    only the unchained initializer must be kept. The main initializer must be removed.
    A comment can be added about that, like: `Note: The "..._init()" initializer has not been provided as redundant`.

5.  Upgradable non-abstract contracts must include a single external or public initializer named `initilize()`.

6.  The initializer of a non-abstract contract must call all NON-empty internal initializers of
    all parent smart contracts in the order of inheritance.
    If a parent smart contract has two initializers, the main one must be called inside the `initilize()` function.

7.  EMPTY internal initializers of all parent contracts must NOT be called inside the `initilize()` function
    except initializers of parent smart contracts that are defined in the current project (see next point).

8.  The initializer of a non-abstract contract must call all EMPTY internal initializers of
    parent smart contracts that are defined in the current project.
    This is important to avoid errors during test coverage assessment.

9.  Internal initializers must use the `onlyInitializing` modifier.

10. External and public initializers must use the `initializer` modifier.

11. All initializers must be documented with NatSpec comments, including descriptions for all input parameters (if any).

12. In the NatSpec comments of the initializer of a non-abstract contract the link to
    the OpenZeppelin's upgradeable pattern documentation must be included, like:
    ```solidity
    /**
     * @dev Initializer of the upgradable contract.
     *
     * See details: https://docs.openzeppelin.com/upgrades-plugins/writing-upgradeable
     */
    ```

13. In the NatSpec comments of the internal initializer of an abstract contract the link to
    the OpenZeppelin's documentation about multiple inheritance in upgradeable contracts must be included, like:
    ```solidity
    /**
     * @dev The unchained internal initializer of the upgradable contract
     *
     * See details: https://docs.openzeppelin.com/contracts/5.x/upgradeable#multiple-inheritance
     */
    ```

# 3. Error Handling Rules

1. Use custom errors instead of revert strings for gas efficiency.

2. Follow a consistent naming pattern for errors with the contract name suffix (e.g., `ContractName_ErrorDescription`).

3. Include relevant parameters into custom errors when appropriate.


# 4. Events Rules

1. Emit events for all state-changing operations.

2. Select clear and descriptive event names.

3. Include both old and new values in events when updating state.

4. Index event parameters that might be used for filtering.

5. Document events in NatSpec comments of functions that emit them, using the formats like:
   `Emits an {EventName} event`, `Emits an {EventName} event for each ...`.
   Do not inlcude events that are NOT defined in the project files, e.g. from third-party libraries.


# 5. Comments Rules

1.  If NatSpec comments for a code entity consist of more than one line, use the `/** */` comment style.

2.  If NatSpec comments for a code entity consist of a single line, use the `///` comment style.

3.  Put the licence identifier comment at the beginning of a Solidity file, like: `// SPDX-License-Identifier: MIT`.

4.  NatSpec tags `@title` and `@author` must exist in the comments for all interfaces, classes, libraries, e.g.
    ```solidity
    /**
     * @title RescuableUpgradeable base contract
     * @author CloudWalk Inc. (See https://www.cloudwalk.io)
     * @dev Allows to rescue ERC20 tokens locked up in the contract using the {RESCUER_ROLE} role.
       */
       abstract contract RescuableUpgradeable is AccessControlExtUpgradeable {....}
    ```

5.  Sections of code within interfaces, contracts, libraries must be separated by section separator comments, e.g.:
    ```solidity
    contract MyContract {
        // ------------------ Constants ------------------------------- //

        ....
        bytes32 public constant OWNER_ROLE = keccak256("OWNER_ROLE");
        ....

        // ------------------ Constructor ----------------------------- //

        ....
        constructor() { _disableInitializers();}

        // ------------------ Initializers ---------------------------- //

        ....
        function initialize(address token_) external initializer {....}

        // ------------------ Transactional functions ----------------- //

        function setOperationalTreasury(address newTreasury) external onlyRole(OWNER_ROLE) {....}
        ....

        // ------------------ View functions -------------------------- //

        ....
        function getOperation(bytes32 opId) external view returns (Operation memory) {....}
        ....

        // ------------------ Pure functions -------------------------- //

        ....
        function proveMyContract() external pure {}
        ....

        // ------------------ Internal functions ---------------------- //
        
        ....
        function _executeOperation(address account, uint256 amount, bytes32 opId, uint256 operationKind) internal { }
        ....
    }
    ```

6.  Section separator comments must be single-line and exactly 70 characters long.

7.  The first section separator comment in an interface, contract, or library may be omitted.

8.  The section separator comment must be omitted if the interface, contract, library contains only one logical section.
    Example: an interface containing only a list of custom errors.

9.  NatSpec comments for an enum must include descriptions for all enum values including their number equivalents like:
    ```solidity
    /**
     * @dev Possible statuses of a an operation used in the blueprint smart contract.
     *
     * The values:
     *
     * - Nonexistent = 0 -- The operation does not exist (the default value).
     * - Deposit = 1 ------ The deposit operation has been executed.
     * - Withdrawal = 2 --- The withdrawal operation has been executed.
     */
    enum OperationStatus {
        Nonexistent,
        Deposit,
        Withdrawal
    }
    ```

10. NatSpec comments for a structure must include descriptions for all fields like:
     ```solidity
     /**
      * @dev The data of a single operation of the blueprint smart-contract.
      *
      * The fields:
      *
      * - status --- The status of the operation according to the {OperationStatus} enum.
      * - account -- The address of the account involved in the operation.
      * - amount --- The amount parameter of the related operation.
      */
     struct Operation {
         uint8 status;
         address account;
         uint64 amount;
         // uint24 __reserved; // Reserved for future use until the end of the storage slot
     }
     ```
    
11. Structures must include comments about free space until the end of a storage slot and about slot numbers, like:
    ```solidity
    struct AccountState {
        // Slot 1
        bytes32 lastOpId;
        // No reserve until the end of the storage slot

        // Slot 2
        uint64 balance;
        uint32 operationCount;
        // uint160 __reserved; // Reserved for future use until the end of the storage slot
    }
    ```

12. Structures that fit into a single storage slot must not include comments about slot numbers,
    but still must have comments about free space to the end of the storage slot.


# 6. Example Project


## 6.1. File Structure

- **Root Directory**:
  * `contracts/` -- Main directory for all smart contracts
  * `test/` -- Contains all test files
  * `scripts/` -- Deployment and utility scripts
  * `docs/` -- Documentation files
  * Configuration files (hardhat.config.js, package.json, etc.)

- **Contracts Directory (`contracts/`)**:
  * `Blueprint.sol` -- Main implementation contract
  * `BlueprintStorageLayout.sol` -- Storage layout contract with state variables
  * `base/` -- Base contracts and common functionality
    - `AccessControlExtUpgradeable.sol` -- Role-based access control extension
    - `PausableExtUpgradeable.sol` -- Pause/unpause functionality
    - `RescuableUpgradeable.sol` -- Token rescue functionality
    - `UUPSExtUpgradeable.sol` -- Extended UUPS upgrade mechanisms
    - `Versionable.sol` -- Contract versioning functionality
  * `interfaces/` - Interface definitions
    - `IBlueprint.sol` -- Main interface with primary and configuration functions
    - `IBlueprintTypes.sol` -- Data types for the Blueprint contract
    - `IVersionable.sol` -- Interface for contract versioning
  * `mocks/` -- Mock contracts for testing
    - `base/` -- Mock implementations of base contracts
      - `AccessControlExtUpgradeableMock.sol` -- Mock for access control
      - `PausableExtUpgradeableMock.sol` -- Mock for pause functionality
      - `RescuableUpgradeableMock.sol` -- Mock for rescue functionality
      - `UUPSExtUpgradableMock.sol` -- Mock for UUPS extension
    - `tokens/` -- Mock token implementations
      - `ERC20TokenMock.sol` -- ERC20 token for testing
  * `testables/` -- Testable versions with helper functions
    - `BlueprintTestable.sol` -- Extended version of Blueprint for testing


## 6.2. Project Files


### 6.2.1. Main Contract Files

- **contracts/Blueprint.sol**:
    ```solidity
    // SPDX-License-Identifier: MIT

    pragma solidity 0.8.24;

    import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";

    import { AccessControlExtUpgradeable } from "./base/AccessControlExtUpgradeable.sol";
    import { PausableExtUpgradeable } from "./base/PausableExtUpgradeable.sol";
    import { RescuableUpgradeable } from "./base/RescuableUpgradeable.sol";
    import { Versionable } from "./base/Versionable.sol";
    import { UUPSExtUpgradeable } from "./base/UUPSExtUpgradeable.sol";

    import { IBlueprint } from "./interfaces/IBlueprint.sol";
    import { IBlueprintPrimary } from "./interfaces/IBlueprint.sol";
    import { IBlueprintConfiguration } from "./interfaces/IBlueprint.sol";

    import { BlueprintStorageLayout } from "./BlueprintStorageLayout.sol";

    /**
     * @title Blueprint contract
     * @author CloudWalk Inc. (See https://www.cloudwalk.io)
     * @dev The contract that responsible for freezing operations on the underlying token contract.
     *
     * See details about the contract in the comments of the {IBlueprint} interface.
     */
    contract Blueprint is
        BlueprintStorageLayout,
        AccessControlExtUpgradeable,
        PausableExtUpgradeable,
        RescuableUpgradeable,
        UUPSExtUpgradeable,
        Versionable,
        IBlueprint
    {
        // ------------------ Constants ------------------------------- //

        /// @dev The kind of operation that is deposit.
        uint256 internal constant OPERATION_KIND_DEPOSIT = 0;

        /// @dev The kind of operation that is withdrawal.
        uint256 internal constant OPERATION_KIND_WITHDRAWAL = 1;

        // ------------------ Constructor ----------------------------- //

        /// @dev Constructor that prohibits the initialization of the implementation of the upgradable contract.
        /// @custom:oz-upgrades-unsafe-allow constructor
        constructor() {
            _disableInitializers();
        }

        // ------------------ Initializers ---------------------------- //

        /**
         * @dev Initializer of the upgradable contract.
         *
         * See details: https://docs.openzeppelin.com/upgrades-plugins/writing-upgradeable
         *
         * @param token_ The address of the token to set as the underlying one.
         */
        function initialize(address token_) external initializer {
            __AccessControlExt_init_unchained(); // This is needed only to avoid errors during coverage assessment
            __PausableExt_init(OWNER_ROLE);
            __Rescuable_init(OWNER_ROLE);
            __UUPSExt_init_unchained(); // This is needed only to avoid errors during coverage assessment

            if (token_ == address(0)) {
                revert Blueprint_TokenAddressZero();
            }

            _getBlueprintStorage().token = token_;

            _setRoleAdmin(OWNER_ROLE, OWNER_ROLE);
            _setRoleAdmin(MANAGER_ROLE, OWNER_ROLE);
            _grantRole(OWNER_ROLE, _msgSender());
        }

        // ------------------ Transactional functions ----------------- //

        /**
         * @inheritdoc IBlueprintConfiguration
         *
         * @dev Requirements:
         *
         * - The caller must have the {MANAGER_ROLE} role.
         * - The new operational treasury address must not be zero.
         * - The new operational treasury address must not be the same as already configured.
         */
        function setOperationalTreasury(address newTreasury) external onlyRole(OWNER_ROLE) {
            BlueprintStorage storage $ = _getBlueprintStorage();
            address oldTreasury = $.operationalTreasury;
            if (newTreasury == oldTreasury) {
                revert Blueprint_TreasuryAddressAlreadyConfigured();
            }
            if (newTreasury != address(0)) {
                if (IERC20($.token).allowance(newTreasury, address(this)) == 0) {
                    revert Blueprint_TreasuryAllowanceZero();
                }
            }

            emit OperationalTreasuryChanged(newTreasury, oldTreasury);
            $.operationalTreasury = newTreasury;
        }

        /**
         * @inheritdoc IBlueprintPrimary
         *
         * @dev Requirements:
         *
         * - The contract must not be paused.
         * - The caller must have the {MANAGER_ROLE} role.
         * - The provided account address must not be zero.
         * - The provided operation identifier must not be zero.
         */
        function deposit(
            address account, // Tools: this comment prevents Prettier from formatting into a single line
            uint256 amount,
            bytes32 opId
        ) external whenNotPaused onlyRole(MANAGER_ROLE) {
            _executeOperation(account, amount, opId, OPERATION_KIND_DEPOSIT);
        }

        /**
         * @inheritdoc IBlueprintPrimary
         *
         * @dev Requirements:
         *
         * - The contract must not be paused.
         * - The caller must have the {MANAGER_ROLE} role.
         * - The provided account address must not be zero.
         * - The provided operation identifier must not be zero.
         */
        function withdraw(
            address account, // Tools: this comment prevents Prettier from formatting into a single line
            uint256 amount,
            bytes32 opId
        ) external whenNotPaused onlyRole(MANAGER_ROLE) {
            _executeOperation(account, amount, opId, OPERATION_KIND_WITHDRAWAL);
        }

        // ------------------ View functions -------------------------- //

        /// @inheritdoc IBlueprintPrimary
        function getOperation(bytes32 opId) external view returns (Operation memory) {
            return _getBlueprintStorage().operations[opId];
        }

        /// @inheritdoc IBlueprintPrimary
        function getAccountState(address account) external view returns (AccountState memory) {
            return _getBlueprintStorage().accountStates[account];
        }

        /// @inheritdoc IBlueprintPrimary
        function balanceOf(address account) public view returns (uint256) {
            return _getBlueprintStorage().accountStates[account].balance;
        }

        /// @inheritdoc IBlueprintPrimary
        function underlyingToken() external view returns (address) {
            return _getBlueprintStorage().token;
        }

        /// @inheritdoc IBlueprintConfiguration
        function operationalTreasury() external view returns (address) {
            return _getBlueprintStorage().operationalTreasury;
        }

        // ------------------ Pure functions -------------------------- //

        /// @inheritdoc IBlueprint
        function proveBlueprint() external pure {}

        // ------------------ Internal functions ---------------------- //

        /**
         * @dev Executes an operation on the contract.
         * @param account The account involved in the operation.
         * @param amount The amount of the operation.
         * @param opId The off-chain identifier of the operation.
         * @param operationKind The kind of operation: 0 - deposit, 1 - withdrawal.
         */
        function _executeOperation(address account, uint256 amount, bytes32 opId, uint256 operationKind) internal {
            _checkOperationParameters(account, amount, opId);
            BlueprintStorage storage $ = _getBlueprintStorage();
            address treasury = _getAndCheckOperationalTreasury($);

            Operation storage operation = _getAndCheckOperation(opId, $);
            operation.account = account;
            operation.amount = uint64(amount);

            AccountState storage state = $.accountStates[account];

            uint256 oldBalance = state.balance;
            uint256 newBalance = oldBalance;

            if (operationKind == OPERATION_KIND_DEPOSIT) {
                operation.status = OperationStatus.Deposit;
                newBalance += amount;
                if (newBalance > type(uint64).max) {
                    revert Blueprint_BalanceExcess();
                }
            } else {
                newBalance -= amount;
                operation.status = OperationStatus.Withdrawal;
            }

            state.balance = uint64(newBalance);
            state.operationCount += 1;
            state.lastOpId = opId;

            emit BalanceUpdated(
                opId, // Tools: this comment prevents Prettier from formatting into a single line
                account,
                newBalance,
                oldBalance
            );

            if (operationKind == OPERATION_KIND_DEPOSIT) {
                IERC20($.token).transferFrom(account, treasury, amount);
            } else {
                IERC20($.token).transferFrom(treasury, account, amount);
            }
        }

        /**
         * @dev Checks the parameters of an operation.
         * @param account The account involved in the operation.
         * @param amount The amount of the operation.
         * @param opId The off-chain identifier of the operation.
         */
        function _checkOperationParameters(address account, uint256 amount, bytes32 opId) internal pure {
            if (account == address(0)) {
                revert Blueprint_AccountAddressZero();
            }
            if (opId == bytes32(0)) {
                revert Blueprint_OperationIdZero();
            }
            if (amount > type(uint64).max) {
                revert Blueprint_AmountExcess();
            }
        }

        /// @dev Returns the operational treasury address after checking it.
        function _getAndCheckOperationalTreasury(BlueprintStorage storage $) internal view returns (address) {
            address operationalTreasury_ = $.operationalTreasury;
            if (operationalTreasury_ == address(0)) {
                revert Blueprint_OperationalTreasuryAddressZero();
            }
            return operationalTreasury_;
        }

        /**
         * @dev Fetches the current data of an operation and check it.
         * @param opId The off-chain identifier of the operation.
         * @return The current operation.
         */
        function _getAndCheckOperation(bytes32 opId, BlueprintStorage storage $) internal view returns (Operation storage) {
            Operation storage operation = $.operations[opId];
            if (operation.status != OperationStatus.Nonexistent) {
                revert Blueprint_OperationAlreadyExecuted(opId);
            }
            return operation;
        }

        /**
         * @dev The upgrade validation function for the UUPSExtUpgradeable contract.
         * @param newImplementation The address of the new implementation.
         */
        function _validateUpgrade(address newImplementation) internal view override onlyRole(OWNER_ROLE) {
            try IBlueprint(newImplementation).proveBlueprint() {} catch {
                revert Blueprint_ImplementationAddressInvalid();
            }
        }
    }
    ```

- **contracts/BlueprintStorageLayout.sol**:
    ```solidity
    // SPDX-License-Identifier: MIT

    pragma solidity ^0.8.18;

    import { IBlueprintTypes } from "./interfaces/IBlueprintTypes.sol";

    /**
     * @title BlueprintStorage contract
     * @author CloudWalk Inc. (See https://cloudwalk.io)
     * @dev Defines the storage layout for the reference smart-contract.
     *
     * See details about the contract in the comments of the {IBlueprint} interface.
     */
    abstract contract BlueprintStorageLayout is IBlueprintTypes {
        // ------------------ Constants ------------------------------- //

        /// @dev The role of this contract owner.
        bytes32 public constant OWNER_ROLE = keccak256("OWNER_ROLE");

        /// @dev The role of manager that is allowed to deposit and withdraw tokens to the contract.
        bytes32 public constant MANAGER_ROLE = keccak256("MANAGER_ROLE");

        // ------------------ Storage layout -------------------------- //

        /*
         * ERC-7201: Namespaced Storage Layout
         * keccak256(abi.encode(uint256(keccak256("cloudwalk.storage.Blueprint")) - 1)) & ~bytes32(uint256(0xff))
         */
        bytes32 private constant BLUEPRINT_STORAGE_LOCATION =
            0xafe7a9a1707fd5088d626d487a8abd113f3fb4bc089bd4284d3e123585a48c00;

        /**
         * @dev Defines the contract storage structure.
         *
         * The fields:
         *
         * - token ---------------- The address of the underlying token.
         * - operationalTreasury -- The address of the operational treasury.
         * - operations ----------- The mapping of an operation structure for a given off-chain operation identifier.
         * - accountStates -------- The mapping of a state for a given account.
         *
         * Notes:
         * 1. The operational treasury is used to deposit and withdraw tokens through special functions.
         *
         * @custom:storage-location erc7201:cloudwalk.storage.AssetYield
         */
        struct BlueprintStorage {
            // Slot 1
            address token;
            // uint96 __reserved1; // Reserved for future use until the end of the storage slot

            // Slot 2
            address operationalTreasury;
            // uint96 __reserved2; // Reserved for future use until the end of the storage slot

            // Slot 3
            mapping(bytes32 opId => Operation operation) operations;
            // No reserve until the end of the storage slot

            // Slot 4
            mapping(address account => AccountState state) accountStates;
            // No reserve until the end of the storage slot
        }

        // ------------------ Internal functions ---------------------- //

        /// @dev Returns the storage slot location for the `BlueprintdStorage` struct.
        function _getBlueprintStorage() internal pure returns (BlueprintStorage storage $) {
            assembly {
                $.slot := BLUEPRINT_STORAGE_LOCATION
            }
        }
    }

    ```


### 6.2.2. Interface Files

- **contracts/interfaces/IBlueprint.sol**:
    ```solidity
    // SPDX-License-Identifier: MIT

    pragma solidity ^0.8.0;

    import { IBlueprintTypes } from "./IBlueprintTypes.sol";

    /**
     * @title IBlueprintPrimary interface
     * @author CloudWalk Inc. (See https://cloudwalk.io)
     * @dev The primary part of the blueprint smart contract interface.
     *
     * See details about the contract in the comments of the {IBlueprint} interface.
     */
    interface IBlueprintPrimary is IBlueprintTypes {
        // ------------------ Events ---------------------------------- //

        /**
         * @dev Emitted when the balance of a specific account on the smart contract has been updated.
         *
         * The balance update can happen due to a deposit or withdrawal operation.
         *
         * @param opId The off-chain identifier of the operation.
         * @param account The account whose balance has been updated.
         * @param newBalance The updated balance of the account.
         * @param oldBalance The previous balance of the account.
         */
        event BalanceUpdated(
            bytes32 indexed opId, // Tools: this comment prevents Prettier from formatting into a single line
            address indexed account,
            uint256 newBalance,
            uint256 oldBalance
        );

        // ------------------ Transactional functions ----------------- //

        /**
         * @dev Deposits tokens to the smart-contract.
         *
         * During the function call the specified amount of tokens will be transferred from the caller to
         * the configured treasury of the contract and the balance of the provided account will be increased accordingly.
         *
         * This function can be called only by an account with a special role.
         *
         * Emits a {BalanceUpdated} event.
         *
         * @param account The account to increase balance for.
         * @param amount The amount to increase the balance by.
         * @param opId The off-chain identifier of the operation.
         */
        function deposit(
            address account, // Tools: this comment prevents Prettier from formatting into a single line
            uint256 amount,
            bytes32 opId
        ) external;

        /**
         * @dev Withdraws tokens from the smart-contract.
         *
         * During the function call the specified amount of tokens will be transferred back from
         * the configured treasury of the contract to the provided account and
         * the balance of the account will be decreased accordingly.
         *
         * This function can be called only by an account with a special role.
         *
         * Emits a {BalanceUpdated} event.
         *
         * @param account The account to decrease the balance for.
         * @param amount The amount to decrease the balance by.
         * @param opId The off-chain identifier of the operation.
         */
        function withdraw(
            address account, // Tools: this comment prevents Prettier from formatting into a single line
            uint256 amount,
            bytes32 opId
        ) external;

        // ------------------ View and pure functions ----------------- //

        /**
         * @dev Returns the data of a single operation on the smart-contract.
         * @param opId The off-chain identifier of the operation.
         * @return operation The data of the operation.
         */
        function getOperation(bytes32 opId) external view returns (Operation memory operation);

        /**
         * @dev Returns the state of an account.
         * @param account The account to get the state of.
         * @return state The state of the account.
         */
        function getAccountState(address account) external view returns (AccountState memory state);

        /**
         * @dev Retrieves the balance of an account.
         *
         * This function is a shortcut for `getAccountState().balance`.
         *
         * @param account The account to check the balance of.
         * @return The resulting amount of tokens that were transferred to the contract after all operations.
         */
        function balanceOf(address account) external view returns (uint256);

        /// @dev Returns the address of the underlying token contract.
        function underlyingToken() external view returns (address);
    }

    /**
     * @title IBlueprintConfiguration interface
     * @author CloudWalk Inc. (See https://cloudwalk.io)
     * @dev The configuration part of the blueprint smart contract interface.
     */
    interface IBlueprintConfiguration {
        // ------------------ Events ---------------------------------- //

        /**
         * @dev Emitted when the operational treasury address has been changed.
         *
         * See the {operationalTreasury} view function comments for more details.
         *
         * @param newTreasury The updated address of the operational treasury.
         * @param oldTreasury The previous address of the operational treasury.
         */
        event OperationalTreasuryChanged(address newTreasury, address oldTreasury);

        // ------------------ Transactional functions ----------------- //

        /**
         * @dev Sets the operational treasury address.
         *
         * This function can be called only by an account with a special role.
         *
         * Emits an {OperationalTreasuryChanged} event.
         *
         * @param newTreasury The new address of the operational treasury to set.
         */
        function setOperationalTreasury(address newTreasury) external;

        // ------------------ View functions -------------------------- //

        /// @dev Returns the address of the operational treasury of this smart-contract.
        function operationalTreasury() external view returns (address);
    }

    /**
     * @title IBlueprintErrors interface
     * @author CloudWalk Inc. (See https://cloudwalk.io)
     * @dev Defines the custom errors used in the blueprint contract.
     *
     * The errors are ordered alphabetically.
     */
    interface IBlueprintErrors {
        /// @dev Thrown if the provided account address is zero.
        error Blueprint_AccountAddressZero();

        /// @dev Thrown if the provided amount is greater than the allowed maximum.
        error Blueprint_AmountExcess();

        /// @dev Thrown if the result account balance is greater than the allowed maximum.
        error Blueprint_BalanceExcess();

        /// @dev Thrown if the provided new implementation address is not of a blueprint contract.
        error Blueprint_ImplementationAddressInvalid();

        /**
         * @dev Thrown if the operation with the provided identifier is already executed.
         * @param opId The provided off-chain identifier of the related operation.
         */
        error Blueprint_OperationAlreadyExecuted(bytes32 opId);

        /// @dev Thrown if the provided off-chain operation identifier is zero.
        error Blueprint_OperationIdZero();

        /**
         * @dev Thrown if the provided underlying token address is zero.
         *
         * This error can be thrown during the contract initialization.
         */
        error Blueprint_TokenAddressZero();

        /// @dev Thrown if the provided treasury address is already configured.
        error Blueprint_TreasuryAddressAlreadyConfigured();

        /// @dev Thrown if the configured operational treasury address is zero, so token transfer operations are disabled.
        error Blueprint_OperationalTreasuryAddressZero();

        /// @dev Thrown if the provided treasury has not granted the contract allowance to spend tokens.
        error Blueprint_TreasuryAllowanceZero();
    }

    /**
     * @title IBlueprint interface
     * @author CloudWalk Inc. (See https://cloudwalk.io)
     * @dev The full interface of the blueprint smart contract.
     *
     * The smart contract is designed as a reference and template one.
     * It allows to deposit or withdraw tokens with specifying an external (off-chain) identifier.
     * The contract itself does not store tokens on its account.
     * It uses an external storage called the operational treasury that can be configured by the owner of the contract.
     * The contract can be paused, in that case only configuration and non-transactional functions can be called.
     * Depositing, withdrawal, and similar functions are reverted if the contract is paused.
     *
     * Some logic and entities of this contract are just for demonstration purposes and do not have any real use.
     */
    interface IBlueprint is IBlueprintPrimary, IBlueprintConfiguration, IBlueprintErrors {
        /**
         * @dev Proves the contract is the blueprint one. A marker function.
         *
         * It is used for simple contract compliance checks, e.g. during an upgrade.
         * This avoids situations where a wrong contract address is specified by mistake.
         */
        function proveBlueprint() external pure;
    }
    ```

- **contracts/interfaces/IBlueprintTypes.sol**:
    ```solidity
    // SPDX-License-Identifier: MIT

    pragma solidity ^0.8.0;

    /**
     * @title IBlueprintTypes interface
     * @author CloudWalk Inc. (See https://www.cloudwalk.io)
     * @dev Defines the types used in the blueprint smart contract.
     *
     * See details about the contract in the comments of the {IBlueprint} interface.
     */
    interface IBlueprintTypes {
        /**
         * @dev Possible statuses of a an operation used in the blueprint smart contract.
         *
         * The values:
         *
         * - Nonexistent = 0 -- The operation does not exist (the default value).
         * - Deposit = 1 ------ The deposit operation has been executed.
         * - Withdrawal = 2 --- The withdrawal operation has been executed.
         */
        enum OperationStatus {
            Nonexistent,
            Deposit,
            Withdrawal
        }

        /**
         * @dev The data of a single operation of the blueprint smart-contract.
         *
         * The fields:
         *
         * - status --- The status of the operation according to the {OperationStatus} enum.
         * - account -- The address of the account involved in the operation.
         * - amount --- The amount parameter of the related operation.
         */
        struct Operation {
            OperationStatus status;
            address account;
            uint64 amount;
            // uint24 __reserved; // Reserved for future use until the end of the storage slot
        }

        /**
         * @dev The state of a single account within the blueprint smart-contract.
         *
         * The fields:
         *
         * - lastOpId -------- The identifier of the last operation related to the account.
         * - balance --------- The balance of the account.
         * - operationCount -- The number of operations related to the account.
         */
        struct AccountState {
            // Slot 1
            bytes32 lastOpId;
            // No reserve until the end of the storage slot

            // Slot 2
            uint64 balance;
            uint32 operationCount;
            // uint160 __reserved; // Reserved for future use until the end of the storage slot
        }
    }
    ```

- **contracts/interfaces/IVersionable.sol**:
    ```solidity
    // SPDX-License-Identifier: MIT

    pragma solidity ^0.8.0;

    /**
     * @title IVersionable interface
     * @author CloudWalk Inc. (See https://cloudwalk.io)
     * @dev Defines code entities to get the version of a contract.
     */
    interface IVersionable {
        /**
         * @dev Defines the version of a contract.
         *
         * The fields:
         *
         * - major -- The major version of the contract.
         * - minor -- The minor version of the contract.
         * - patch -- The patch version of the contract.
         */
        struct Version {
            uint16 major;
            uint16 minor;
            uint16 patch;
        }

        /// @dev Returns the version of the contract.
        function $__VERSION() external pure returns (Version memory);
    }
    ```


### 6.2.3. Base Contract Files

- **contracts/base/AccessControlExtUpgradeable.sol**:
    ```solidity
    // SPDX-License-Identifier: MIT

    pragma solidity ^0.8.20;

    import { AccessControlUpgradeable } from "@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol";

    /**
     * @title AccessControlExtUpgradeable base contract
     * @author CloudWalk Inc. (See https://www.cloudwalk.io)
     * @dev Extends the OpenZeppelin's {AccessControlUpgradeable} contract by adding the functions
     *      for granting and revoking roles in batch.
     */
    abstract contract AccessControlExtUpgradeable is AccessControlUpgradeable {
        // ------------------ Initializers ---------------------------- //

        /**
         * @dev The unchained internal initializer of the upgradable contract
         *
         * See details: https://docs.openzeppelin.com/contracts/5.x/upgradeable#multiple-inheritance
         *
         * Note: The `..._init()` initializer has not been provided as redundant.
         */
        function __AccessControlExt_init_unchained() internal onlyInitializing {}

        // ------------------ Transactional functions ----------------- //

        /**
         * @dev Grants a role to accounts in batch.
         *
         * Emits a {RoleGranted} event for each account that has not been granted the provided role previously.
         *
         * Requirement: the caller must have the role that is the admin for the role that is being granted.
         *
         * @param role The role to grant.
         * @param accounts The accounts to grant the role to.
         */
        function grantRoleBatch(bytes32 role, address[] memory accounts) public virtual onlyRole(getRoleAdmin(role)) {
            uint256 count = accounts.length;
            for (uint256 i = 0; i < count; ) {
                _grantRole(role, accounts[i]);
                unchecked {
                    ++i;
                }
            }
        }

        /**
         * @dev Revokes a role to accounts in batch.
         *
         * Emits a {RoleRevoked} event for each account that has the provided role previously.
         *
         * Requirement: the caller must have the role that is the admin for the role that is being revoked.
         *
         * @param role The role to revoke.
         * @param accounts The accounts to revoke the role from.
         */
        function revokeRoleBatch(bytes32 role, address[] memory accounts) public virtual onlyRole(getRoleAdmin(role)) {
            uint256 count = accounts.length;
            for (uint256 i = 0; i < count; ) {
                _revokeRole(role, accounts[i]);
                unchecked {
                    ++i;
                }
            }
        }
    }
    ```

- **contracts/base/PausableExtUpgradeable.sol.sol**:
    ```solidity
    // SPDX-License-Identifier: MIT

    pragma solidity ^0.8.20;

    import { AccessControlUpgradeable } from "@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol";
    import { PausableUpgradeable } from "@openzeppelin/contracts-upgradeable/utils/PausableUpgradeable.sol";

    /**
     * @title PausableExtUpgradeable base contract
     * @author CloudWalk Inc. (See https://www.cloudwalk.io)
     * @dev Extends the OpenZeppelin's {PausableUpgradeable} contract by adding the {PAUSER_ROLE} role and implementing
     *      the external pausing and unpausing functions.
     */
    abstract contract PausableExtUpgradeable is AccessControlUpgradeable, PausableUpgradeable {
        /// @dev The role of pauser that is allowed to trigger the paused or unpaused state of the contract.
        bytes32 public constant PAUSER_ROLE = keccak256("PAUSER_ROLE");

        // ------------------ Initializers ---------------------------- //

        /**
         * @dev Internal initializer of the upgradable contract.
         *
         * See details: https://docs.openzeppelin.com/contracts/5.x/upgradeable#multiple-inheritance
         *
         * @param pauserRoleAdmin The admin for the {PAUSER_ROLE} role.
         */
        function __PausableExt_init(bytes32 pauserRoleAdmin) internal onlyInitializing {
            __PausableExt_init_unchained(pauserRoleAdmin);
        }

        /**
         * @dev Unchained internal initializer of the upgradable contract.
         *
         * See details: https://docs.openzeppelin.com/contracts/5.x/upgradeable#multiple-inheritance
         *
         * @param pauserRoleAdmin The admin for the {PAUSER_ROLE} role.
         */
        function __PausableExt_init_unchained(bytes32 pauserRoleAdmin) internal onlyInitializing {
            _setRoleAdmin(PAUSER_ROLE, pauserRoleAdmin);
        }

        // ------------------ Transactional functions ----------------- //

        /**
         * @dev Triggers the paused state of the contract.
         *
         * Requirement: the caller must have the {PAUSER_ROLE} role.
         */
        function pause() public onlyRole(PAUSER_ROLE) {
            _pause();
        }

        /**
         * @dev Triggers the unpaused state of the contract.
         *
         * Requirement: the caller must have the {PAUSER_ROLE} role.
         */
        function unpause() public onlyRole(PAUSER_ROLE) {
            _unpause();
        }
    }
    ```

- **contracts/base/RescuableUpgradeable.sol**:
    ```solidity
    // SPDX-License-Identifier: MIT

    pragma solidity ^0.8.20;

    import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
    import { SafeERC20 } from "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
    import { AccessControlUpgradeable } from "@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol";

    /**
     * @title RescuableUpgradeable base contract
     * @author CloudWalk Inc. (See https://www.cloudwalk.io)
     * @dev Allows to rescue ERC20 tokens locked up in the contract using the {RESCUER_ROLE} role.
     */
    abstract contract RescuableUpgradeable is AccessControlUpgradeable {
        using SafeERC20 for IERC20;

        /// @dev The role of rescuer that is allowed to rescue tokens locked up in the contract.
        bytes32 public constant RESCUER_ROLE = keccak256("RESCUER_ROLE");

        // ------------------ Initializers ---------------------------- //

        /**
         * @dev Internal initializer of the upgradable contract.
         *
         * See details: https://docs.openzeppelin.com/contracts/5.x/upgradeable#multiple-inheritance
         *
         * @param rescuerRoleAdmin The admin for the {RESCUER_ROLE} role.
         */
        function __Rescuable_init(bytes32 rescuerRoleAdmin) internal onlyInitializing {
            __Rescuable_init_unchained(rescuerRoleAdmin);
        }

        /**
         * @dev Unchained internal initializer of the upgradable contract.
         *
         * See details: https://docs.openzeppelin.com/contracts/5.x/upgradeable#multiple-inheritance
         *
         * @param rescuerRoleAdmin The admin for the {RESCUER_ROLE} role.
         */
        function __Rescuable_init_unchained(bytes32 rescuerRoleAdmin) internal onlyInitializing {
            _setRoleAdmin(RESCUER_ROLE, rescuerRoleAdmin);
        }

        // ------------------ Transactional functions ----------------- //

        /**
         * @dev Rescues tokens that accidentally were transferred to this contract.
         *
         * Does not emit special events except ones related to the token transfer.
         *
         * Requirements:
         *
         * - The caller must have the {RESCUER_ROLE} role.
         * - The provided account address must not be zero. It is usually checked inside the token smart-contract.
         *
         * @param token The address of the token smart contract to rescue its coins from this smart contract's account.
         * @param account The account to transfer the rescued tokens to.
         * @param amount The amount the tokens to rescue.
         */
        function rescueERC20(
            address token, // Tools: this comment prevents Prettier from formatting into a single line
            address account,
            uint256 amount
        ) public onlyRole(RESCUER_ROLE) {
            IERC20(token).safeTransfer(account, amount);
        }
    }
    ```

- **contracts/base/UUPSExtUpgradeable.sol**:
    ```solidity
    // SPDX-License-Identifier: MIT

    pragma solidity ^0.8.20;

    import { UUPSUpgradeable } from "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";

    /**
     * @title UUPSExtUpgradeable base contract
     * @author CloudWalk Inc. (See https://www.cloudwalk.io)
     * @dev Extends the OpenZeppelin's {UUPSUpgradeable} contract with additional checks for the new implementation address.
     */
    abstract contract UUPSExtUpgradeable is UUPSUpgradeable {
        /// @dev Thrown if the provided new implementation address is not a contract.
        error UUPSExtUpgradeable_ImplementationAddressNotContract();

        /// @dev Thrown if the provided new implementation contract address is zero.
        error UUPSExtUpgradeable_ImplementationAddressZero();

        // ------------------ Initializers ---------------------------- //

        /**
         * @dev Unchained internal initializer of the upgradable contract.
         *
         * See details: https://docs.openzeppelin.com/contracts/5.x/upgradeable#multiple-inheritance
         *
         * Note: The `..._init()` initializer has not been provided as redundant.
         */
        function __UUPSExt_init_unchained() internal onlyInitializing {}

        // ------------------ Internal functions ---------------------- //

        /**
         * @dev Overrides the upgrade authorization function for UUPSProxy.
         * @param newImplementation The address of the new implementation of a proxy smart contract.
         */
        function _authorizeUpgrade(address newImplementation) internal override {
            if (newImplementation == address(0)) {
                revert UUPSExtUpgradeable_ImplementationAddressZero();
            }

            if (newImplementation.code.length == 0) {
                revert UUPSExtUpgradeable_ImplementationAddressNotContract();
            }

            _validateUpgrade(newImplementation);
        }

        /**
         * @dev Executes further validation steps of the upgrade including authorization and implementation address checks.
         *
         * It is expected that this function will be overridden in successor contracts.
         *
         * @param newImplementation The address of the new implementation.
         */
        function _validateUpgrade(address newImplementation) internal virtual;
    }
    ```

- **contracts/base/Versionable.sol**:
    ```solidity
    // SPDX-License-Identifier: MIT

    pragma solidity ^0.8.0;

    import "../interfaces/IVersionable.sol";

    /**
     * @title Versionable base contract
     * @author CloudWalk Inc. (See https://cloudwalk.io)
     * @dev Defines the contract version.
     */
    abstract contract Versionable is IVersionable {
        /// @inheritdoc IVersionable
        function $__VERSION() external pure returns (Version memory) {
            return Version(1, 1, 0);
        }
    }
    ```


### 6.2.4. Mock Files

- **contracts/mocks/base/AccessControlExtUpgradeableMock.sol**:
    ```solidity
    // SPDX-License-Identifier: MIT

    pragma solidity ^0.8.20;

    import { UUPSUpgradeable } from "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";

    import { AccessControlExtUpgradeable } from "../../base/AccessControlExtUpgradeable.sol";

    /**
     * @title AccessControlExtUpgradeableMock contract
     * @author CloudWalk Inc. (See https://www.cloudwalk.io)
     * @dev An implementation of the {AccessControlExtUpgradeable} contract for test purposes.
     */
    contract AccessControlExtUpgradeableMock is AccessControlExtUpgradeable, UUPSUpgradeable {
        /// @dev The role of this contract owner.
        bytes32 public constant OWNER_ROLE = keccak256("OWNER_ROLE");
        /// @dev The role of a user of this contract.
        bytes32 public constant USER_ROLE = keccak256("USER_ROLE");

        // ------------------ Initializers ---------------------------- //

        /**
         * @dev The initialize function of the upgradable contract.
         *
         * See details: https://docs.openzeppelin.com/upgrades-plugins/writing-upgradeable
         */
        function initialize() public initializer {
            __AccessControlExt_init_unchained(); // This is needed only to avoid errors during coverage assessment

            _setRoleAdmin(USER_ROLE, OWNER_ROLE);
            _grantRole(OWNER_ROLE, _msgSender());

            // Only to provide the 100 % test coverage
            _authorizeUpgrade(address(0));
        }

        // ------------------ Transactional functions ----------------- //

        /// @dev Calls the parent internal unchained initializing function to verify the 'onlyInitializing' modifier.
        function callParentInitializerUnchained() external {
            __AccessControlExt_init_unchained();
        }

        // ------------------ Internal functions ---------------------- //

        /**
         * @dev The implementation of the upgrade authorization function of the parent UUPSProxy contract.
         * @param newImplementation The address of the new implementation.
         */
        function _authorizeUpgrade(address newImplementation) internal pure override {
            newImplementation; // Suppresses a compiler warning about the unused variable.
        }
    }
    ```

- **contracts/mocks/base/PausableExtUpgradeableMock.sol**:
    ```solidity
    // SPDX-License-Identifier: MIT

    pragma solidity ^0.8.20;

    import { UUPSUpgradeable } from "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";

    import { PausableExtUpgradeable } from "../../base/PausableExtUpgradeable.sol";

    /**
     * @title PausableExtUpgradeableMock contract
     * @author CloudWalk Inc. (See https://www.cloudwalk.io)
     * @dev An implementation of the {PausableExtUpgradeable} contract for test purposes.
     */
    contract PausableExtUpgradeableMock is PausableExtUpgradeable, UUPSUpgradeable {
        /// @dev The role of this contract owner.
        bytes32 public constant OWNER_ROLE = keccak256("OWNER_ROLE");

        // ------------------ Initializers ---------------------------- //

        /**
         * @dev The initialize function of the upgradable contract.
         *
         * See details: https://docs.openzeppelin.com/upgrades-plugins/writing-upgradeable
         */
        function initialize() public initializer {
            __PausableExt_init(OWNER_ROLE);

            _grantRole(OWNER_ROLE, _msgSender());

            // Only to provide the 100 % test coverage
            _authorizeUpgrade(address(0));
        }

        // ------------------ Transactional functions ----------------- //

        /// @dev Calls the parent internal initializing function to verify the 'onlyInitializing' modifier.
        function callParentInitializer() external {
            __PausableExt_init(OWNER_ROLE);
        }

        /// @dev Calls the parent internal unchained initializing function to verify the 'onlyInitializing' modifier.
        function callParentInitializerUnchained() external {
            __PausableExt_init_unchained(OWNER_ROLE);
        }

        // ------------------ Internal functions ---------------------- //

        /**
         * @dev The implementation of the upgrade authorization function of the parent UUPSProxy contract.
         * @param newImplementation The address of the new implementation.
         */
        function _authorizeUpgrade(address newImplementation) internal pure override {
            newImplementation; // Suppresses a compiler warning about the unused variable
        }
    }
    ```

- **contracts/mocks/base/RescuableUpgradeableMock.sol**:
    ```solidity
    // SPDX-License-Identifier: MIT

    pragma solidity ^0.8.20;

    import { UUPSUpgradeable } from "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";

    import { RescuableUpgradeable } from "../../base/RescuableUpgradeable.sol";

    /**
     * @title RescuableUpgradeableMock contract
     * @author CloudWalk Inc. (See https://www.cloudwalk.io)
     * @dev An implementation of the {RescuableUpgradeable} contract for test purposes.
     */
    contract RescuableUpgradeableMock is RescuableUpgradeable, UUPSUpgradeable {
        /// @dev The role of this contract owner.
        bytes32 public constant OWNER_ROLE = keccak256("OWNER_ROLE");

        // ------------------ Initializers ---------------------------- //

        /**
         * @dev The initialize function of the upgradable contract.
         *
         * See details: https://docs.openzeppelin.com/upgrades-plugins/writing-upgradeable
         */
        function initialize() public initializer {
            __Rescuable_init(OWNER_ROLE);

            _grantRole(OWNER_ROLE, _msgSender());

            // Only to provide the 100 % test coverage
            _authorizeUpgrade(address(0));
        }

        // ------------------ Transactional functions ----------------- //

        /// @dev Calls the parent internal initializing function to verify the 'onlyInitializing' modifier.
        function callParentInitializer() external {
            __Rescuable_init(OWNER_ROLE);
        }

        /// @dev Calls the parent internal unchained initializing function to verify the 'onlyInitializing' modifier.
        function callParentInitializerUnchained() external {
            __Rescuable_init_unchained(OWNER_ROLE);
        }

        // ------------------ Internal functions ---------------------- //

        /**
         * @dev The implementation of the upgrade authorization function of the parent UUPSProxy contract.
         * @param newImplementation The address of the new implementation.
         */
        function _authorizeUpgrade(address newImplementation) internal pure override {
            newImplementation; // Suppresses a compiler warning about the unused variable
        }
    }
    ```

- **contracts/mocks/base/UUPSExtUpgradableMock.sol**:
    ```solidity
    // SPDX-License-Identifier: MIT

    pragma solidity ^0.8.20;

    import { UUPSExtUpgradeable } from "../../base/UUPSExtUpgradeable.sol";

    /**
     * @title UUPSExtUpgradableMock contract
     * @author CloudWalk Inc. (See https://www.cloudwalk.io)
     * @dev An implementation of the {UUPSExtUpgradable} contract for test purposes.
     */
    contract UUPSExtUpgradeableMock is UUPSExtUpgradeable {
        /// @dev Emitted when the internal `_validateUpgrade()` function is called with the parameters of the function.
        event MockValidateUpgradeCall(address newImplementation);

        // ------------------ Initializers ---------------------------- //

        /**
         * @dev The initialize function of the upgradable contract.
         *
         * See details: https://docs.openzeppelin.com/upgrades-plugins/writing-upgradeable
         */
        function initialize() public initializer {
            __UUPSExt_init_unchained(); // This is needed only to avoid errors during coverage assessment
        }

        // ------------------ Transactional functions ----------------- //

        /// @dev Calls the parent internal unchained initializing function to verify the 'onlyInitializing' modifier.
        function callParentInitializerUnchained() external {
            __UUPSExt_init_unchained();
        }

        /**
         * @dev An implementation of the validateUpgrade function of the UUPSExtUpgradeable contract.
         *
         * Does not execute any validation steps, just emits an event with the parameter of the function.
         *
         * @param newImplementation The address of the new implementation.
         */
        function _validateUpgrade(address newImplementation) internal override {
            emit MockValidateUpgradeCall(newImplementation);
        }
    }
    ```

- **contracts/mocks/tokens/ERC20TokenMock.sol**:
    ```solidity
    // SPDX-License-Identifier: MIT

    pragma solidity ^0.8.20;

    import { ERC20 } from "@openzeppelin/contracts/token/ERC20/ERC20.sol";

    /**
     * @title ERC20TokenMock contract
     * @author CloudWalk Inc. (See https://www.cloudwalk.io)
     * @dev An implementation of the {ERC20} contract for testing purposes.
     */
    contract ERC20TokenMock is ERC20 {
        /**
         * @dev The constructor of the contract.
         * @param name_ The name of the token to set for this ERC20-comparable contract.
         * @param symbol_ The symbol of the token to set for this ERC20-comparable contract.
         */
        constructor(string memory name_, string memory symbol_) ERC20(name_, symbol_) {}

        // ------------------ Transactional functions ----------------- //

        /**
         * @dev Calls the appropriate internal function to mint needed amount of tokens for an account.
         * @param account The address of an account to mint for.
         * @param amount The amount of tokens to mint.
         */
        function mint(address account, uint256 amount) external {
            _mint(account, amount);
        }
    }
    ```


### 6.2.5. Testable Files

- **contracts/testables/BlueprintTestable.sol**:
    ```solidity
    // SPDX-License-Identifier: MIT

    pragma solidity ^0.8.24;

    import { Blueprint } from "../Blueprint.sol";

    /**
     * @title Blueprint contract
     * @author CloudWalk Inc. (See https://www.cloudwalk.io)
     * @dev The version of the blueprint contract with additions required for testing.
     * @custom:oz-upgrades-unsafe-allow missing-initializer
     */
    contract BlueprintTestable is Blueprint {
        /**
         * @dev Sets the state of an account.
         * @param account The account to set the state of.
         * @param newState The new state of the account.
         */
        function setAccountState(address account, AccountState calldata newState) public {
            _getBlueprintStorage().accountStates[account] = newState;
        }
    }
    ```